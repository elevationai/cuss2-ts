// Build script to create a browser-compatible JavaScript bundle
import { ensureDir } from "@std/fs";
import * as path from "@std/path";
import * as esbuild from "esbuild";
import { denoPlugins } from "@luca/esbuild-deno-loader";
import { parse } from "@std/jsonc";

const outDir = "./docs/dist";
const tempDir = "./.temp";

interface DenoConfig {
  version?: string;
  imports?: Record<string, string>;
  [key: string]: unknown;
}

const denoConfig = parse(await Deno.readTextFile("./deno.jsonc")) as DenoConfig;

const importMap = {
  imports: {
    ...denoConfig.imports,
    events: "npm:events", // the plugin doesn't understand the node: prefix, so we just switch it to npm: here
  },
};

console.log("üî® Building CUSS2 JavaScript browser bundle...");

// Create dist and temp directories if they don't exist
await ensureDir(outDir);
await ensureDir(tempDir);

const entryFile = path.join(tempDir, "bundle-entry.js");

// Create a wrapper entrypoint that properly handles imports
const entryCode = `
// Temporary bundle entry point
import { Cuss2 } from "../mod.ts";

// Re-export Cuss2 as primary export
export { Cuss2 };

// Also create named exports for everything from cuss2-typescript-models
import * as Models from "cuss2-typescript-models";

// Add all models under a 'Models' namespace
export { Models };

// Export helpers and state change
export * from "../src/helper.ts";
export * from "../src/models/stateChange.ts";

// Export Connection for direct access
export * from "../src/connection.ts";
`;

await Deno.writeTextFile(entryFile, entryCode);

// Bundle the main entry point
console.log("üì¶ Bundling TypeScript code...");

try {
  const commonBuildOptions: esbuild.BuildOptions = {
    plugins: [
      {
        name: "browser-aliases",
        setup(build) {
          // Replace ./WebSocket.ts with empty content for browser builds
          build.onResolve({ filter: /\/WebSocket\.ts$/ }, (args) => {
            // Only handle relative imports
            if (args.path.startsWith("./") || args.path.startsWith("../")) {
              return {
                path: "virtual:websocket-browser",
                namespace: "websocket-browser",
              };
            }
          });

          // Return empty content for the virtual module
          build.onLoad({ filter: /.*/, namespace: "websocket-browser" }, () => {
            return {
              contents: "// WebSocket polyfill not needed in browser",
              loader: "js",
            };
          });
        },
      },
      ...denoPlugins({ importMapURL: `data:application/json,${JSON.stringify(importMap)}` }),
    ],
    entryPoints: ["file://" + path.resolve(entryFile)], // esbuild requires absolute paths or relative to CWD
    bundle: true,
    globalName: "Cuss2", // This will be the global variable name for the IIFE
    platform: "browser", // Target the browser environment
    format: "iife", // Output an IIFE, suitable for browser globals
    treeShaking: true, // Enable tree shaking to remove unused code
    // REMOVED: external: ['events', 'node:events'],
    // To help debug which files are included and where 'events' might be coming from if issues persist:
    // metafile: true,
  };

  // Build IIFE version for script tags
  const result = await esbuild.build({
    ...commonBuildOptions,
    outfile: path.join(outDir, "cuss2.js"),
  });

  console.log(
    `‚úÖ IIFE bundle created successfully with ${result.errors.length} errors and ${result.warnings.length} warnings`,
  );

  // Also create a minified IIFE version
  await esbuild.build({
    ...commonBuildOptions,
    outfile: path.join(outDir, "cuss2.min.js"),
    minify: true,
    sourcemap: true,
  });

  console.log("‚úÖ Minified IIFE bundle created successfully");

  // Build ESM version for module imports
  await esbuild.build({
    ...commonBuildOptions,
    format: "esm", // Override format to ESM
    globalName: undefined, // No global name needed for ESM
    outfile: path.join(outDir, "cuss2.esm.js"),
  });

  console.log("‚úÖ ESM bundle created successfully");

  // Also create a minified ESM version
  await esbuild.build({
    ...commonBuildOptions,
    format: "esm", // Override format to ESM
    globalName: undefined, // No global name needed for ESM
    outfile: path.join(outDir, "cuss2.esm.min.js"),
    minify: true,
    sourcemap: true,
  });

  console.log("‚úÖ Minified ESM bundle created successfully");

  // Write wrapper script that makes all exports available on Cuss2 global
  console.log("üìù Writing wrapper script to expose Cuss2 on global object...");

  const jsCode = await Deno.readTextFile(path.join(outDir, "cuss2.js"));
  const minJsCode = await Deno.readTextFile(path.join(outDir, "cuss2.min.js"));

  // Create wrapper to expose Cuss2 on window/globalThis
  // This appends to the IIFE generated by esbuild.
  const wrapper = `
// Appended wrapper to expose Cuss2 exports onto a global Cuss2 object
;(function(globalCtx) {
  if (typeof Cuss2 === 'undefined') {
    console.error('Cuss2 not found. The bundle might have failed to load or was not generated correctly.');
    return;
  }
  // The IIFE bundle creates a global 'Cuss2' object containing all exports
  const _c2 = Cuss2;
  
  // The Cuss2 constructor should be at _c2.Cuss2
  if (_c2.Cuss2 && typeof _c2.Cuss2.connect === 'function') {
    // Make the Cuss2 constructor the main export
    const Cuss2Constructor = _c2.Cuss2;
    
    // Copy all other exports as properties on the constructor
    for (const key in _c2) {
      if (Object.prototype.hasOwnProperty.call(_c2, key)) {
        Cuss2Constructor[key] = _c2[key];
      }
    }
    
    globalCtx.Cuss2 = Cuss2Constructor;
  } else {
    // Fallback: just expose the whole bundle
    globalCtx.Cuss2 = _c2;
  }
  // Move StateChange and LogMessage to Models namespace if they exist
  if (globalCtx.Cuss2.Models && _c2.StateChange) {
    globalCtx.Cuss2.Models.StateChange = _c2.StateChange;
    delete globalCtx.Cuss2.StateChange;
  }
  if (globalCtx.Cuss2.Models && _c2.LogMessage) {
    globalCtx.Cuss2.Models.LogMessage = _c2.LogMessage;
    delete globalCtx.Cuss2.LogMessage;
  }

  // Add version info (consider making this dynamic, e.g., from a version file or package.json)
  globalCtx.Cuss2.version = "${denoConfig.version}";
})(typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis : this);
`;

  await Deno.writeTextFile(path.join(outDir, "cuss2.js"), jsCode + wrapper);
  await Deno.writeTextFile(path.join(outDir, "cuss2.min.js"), minJsCode + wrapper);

  console.log("‚úÖ Build complete!");
  console.log(`üì¶ Browser bundles created at:
  - ${outDir}/cuss2.js (IIFE for script tags)
  - ${outDir}/cuss2.min.js (Minified IIFE)
  - ${outDir}/cuss2.esm.js (ESM for imports)
  - ${outDir}/cuss2.esm.min.js (Minified ESM)`);
}
catch (error) {
  console.error("‚ùå Build failed:", error);
  Deno.exit(1);
}
finally {
  // Clean up temporary file and directory
  try {
    await Deno.remove(tempDir, { recursive: true });
    console.log("üßπ Cleaned up temporary directory.");
  }
  catch (cleanupError) {
    console.warn("‚ö†Ô∏è Could not clean up temporary directory:", (cleanupError as Error).message);
  }
  esbuild.stop(); // Stop the esbuild service
}
